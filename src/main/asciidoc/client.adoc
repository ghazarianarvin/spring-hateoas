[[client]]
= Client-side Support
:base-dir: ../../../

This section describes Spring HATEOAS's support for clients.

[[client.traverson]]
== Traverson

Spring HATEOAS provides an API for client-side service traversal. It is inspired by the https://blog.codecentric.de/en/2013/11/traverson/[Traverson JavaScript library].
The following example shows how to use it:

====
[source, java, tabsize=2]
----
Map<String, Object> parameters = new HashMap<>();
parameters.put("user", 27);

Traverson traverson = new Traverson(URI.create("http://localhost:8080/api/"), MediaTypes.HAL_JSON);
String name = traverson
		.follow("movies", "movie", "actor").withTemplateParameters(parameters)
		.toObject("$.name");
----
====

You can set up a `Traverson` instance by pointing it to a REST server and configuring the media types you want to set as `Accept` headers. You can then define the relation names you want to discover and follow. Relation names can either be simple names or JSONPath expressions (starting with an `$`).

The sample then hands a parameter map into the execution. The parameters are used to expand URIs (which are templated) found during the traversal. The traversal is concluded by accessing the representation of the final traversal. In the preceding example, we evaluate a JSONPath expression to access the actor's name.

The preceding example is the simplest version of traversal, where the `rel` values are strings and, at each hop, the same template parameters are applied.

There are more options to customize template parameters at each level.
The following example shows these options.

[source,java,indent=0, tabsize=2]
----
include::{base-dir}/src/test/java/org/springframework/hateoas/client/TraversonTest.java[tag=hop-with-param]
----

The static `rel(...)` function is a convenient way to define a single `Hop`. Using `.withParameter(key, value)` makes it simple to specify URI template variables.

NOTE: `.withParameter()` returns a new `Hop` object that is chainable. You can string together as many `.withParameter` as you like. The result is a single `Hop` definition.
The following example shows one way to do so:

====
[source,java,indent=0, tabsize=2]
----
include::{base-dir}/src/test/java/org/springframework/hateoas/client/TraversonTest.java[tag=hop-put]
----
====

You can also load an entire `Map` of parameters by using `.withParameters(Map)`.

NOTE: `follow()` is chainable, meaning you can string together multiple hops, as shown in the preceding examples. You can either put multiple string-based `rel` values (`follow("items", "item")`) or a single hop with specific parameters.

=== `EntityModel<T>` vs. `CollectionModel<T>`

The examples shown so far demonstrate how to sidestep Java's type erasure and convert a single JSON-formatted resource into a `EntityModel<Item>` object. However, what if you get a collection like an `\_embedded` HAL collection?
You can do so with only one slight tweak, as the following example shows:

====
[source,java, tabsize=2]
----
CollectionModelType<Item> collectionModelType =
		TypeReferences.CollectionModelType<Item>() {};

CollectionModel<Item> itemResource = traverson.//
		follow(rel("items")).//
		toObject(collectionModelType);
----
====

Instead of fetching a single resource, this one deserializes a collection into `CollectionModel`.

[[client.link-discoverer]]
== Using `LinkDiscoverer` Instances

When working with hypermedia enabled representations, a common task is to find a link with a particular relation type in it. Spring HATEOAS provides https://code.google.com/p/json-path[JSONPath]-based implementations of the `LinkDiscoverer` interface for either the default representation rendering or HAL out of the box. When using `@EnableHypermediaSupport`, we automatically expose an instance supporting the configured hypermedia type as a Spring bean.

Alternatively, you can set up and use an instance as follows:

====
[source, java]
----
String content = "{'_links' :  { 'foo' : { 'href' : '/foo/bar' }}}";
LinkDiscoverer discoverer = new HalLinkDiscoverer();
Link link = discoverer.findLinkWithRel("foo", content);

assertThat(link.getRel(), is("foo"));
assertThat(link.getHref(), is("/foo/bar"));
----
====

[[client.rest-template]]
== Configuring RestTemplate instances

If you need configure a `RestTemplate` to speak hypermedia, there are several ways to do it. In any situation, you need to get a hold of the `WebConverter` created by Spring HATEOAS.

.Configuring a `RestTemplate` yourself
====
[source, java]
----
include::{base-dir}/src/docs/java/org/springframework/hateoas/client/SampleService.java[tag=code]
----
<1> As a Spring-based service, *constructor injection* will give you a copy of Spring HATEOAS's `WebConverters` bean.
<2> Create a `RestTemplate` instance yourself.
<3> Using `WebConverters`, register it's hypermedia-based converters in addition to the ones provided by the Spring Framework by default.
====

You are free to apply this pattern to any instance of `RestTemplate` that you find.

If you're using Spring Boot, there is another approach.

In general, Spring Boot has moved away from the concept of registering a `RestTemplate`-based bean in the application context.

* When talking to different services, you often need different credentials.
* When `RestTemplate` uses an underlying connection pool, you run into additional issues.
* Users often need different instances rather than a single bean.

To compensate for this, Spring Boot provides a `RestTemplateBuilder`. This autoconfigured bean lets you define various beans used to fashion
a `RestTemplate` instance. You ask for a `RestTemplateBuilder` bean, execute its `build()` method, and then apply final settings (like credentials, etc.).

To register hypermedia-based message converters, add the following to your code:

.Letting Spring Boot configure things
====
[source,java]
----
@Bean // <4>
RestTemplateCustomizer hypermediaRestTemplatCustomizer(WebConverters converters) { // <1>
    return restTemplate -> { // <2>
        restTemplate.setMessageConverters(converters.and(restTemplate.getMessageConverters())); // <3>
    };
}
----
<1> When creating a Spring bean, request a copy of Spring HATEOAS's `WebConverters` bean.
<2> Use a Java 8 lambda expression to define a `RestTemplateCustomizer`.
<3> Inside the function call, apply the same pattern seen earlier.
<4> Return the whole thing as a Spring bean so Spring Boot can pick it up and apply it to its autoconfigured `RestTemplateBuilder`.
====

Assuming you added the `RestTemplateCustomizer` bean definition, this is all you must do to get a `RestTemplate` with hypermedia support:

.Injecting `RestTemplateBuilder` into your service
====
[source,java]
----
@Service
public class SampleService {

    private RestTemplateBuilder restTemplateBuilder;

    public SampleService(RestTemplateBuilder restTemplateBuilder) { // <1>
        this.restTemplateBuilder = restTemplateBuilder;
    }

    void doSomething() {
        RestTemplate template = restTemplateBuilder.build(); // <2>

        // Your template is now set up to do hypermedia!
    }
}
----
<1> Use *constructor injection* to get a hold of Spring Boot's `RestTemplateBuilder`.
<2> When you need a `RestTemplate`, invoke `build()`. The instance will have tapped your `RestTemplateCustomizer` code and registered support.
====

That's all it takes to get `RestTemplate` hypermedia support.
